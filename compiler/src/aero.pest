source = { SOI ~ ws? ~ defs? ~ ws? ~ EOI }

/// --- Definitions ---

def = _{ main_def | func_def }
defs = _{ def ~ (ws ~ def)* }

main_def = {
    "(" ~ ws? ~ "main" ~ ws ~
    "do:" ~ ws ~ block? ~ ws? ~
    ")"
}
func_def = {
    "(" ~ ws? ~ "func" ~ ws ~ ident ~
    (ws ~ ascription | label ~ ws ~ ascription)* ~ ws ~ "->" ~ ws ~ block ~ ws ~
    "do:" ~ ws ~ block? ~ ws? ~
    ")"
}

// --- Forms ---

// A form can have a prefix and postfix with no spaces. Only one prefix and
// can be applied.
// Infix forms also allow infix operators in contexts where they are allowed.
// Infix operators must also have spaces around them. This allows for the
// grammar to unambiguous with blocks, where infix forms are joined on commas
// or on newlines where there is no next infix operator.
form = { prefix? ~ primary ~ postfix? }
forms = _{ form ~ (ws ~ form)* }

infix_form = {
    prefix? ~ primary ~ postfix? ~
    (ws ~ infix ~ ws ~ prefix? ~ primary ~ postfix?)*
}

block = { infix_form ~ (block_break ~ infix_form)* }
block_break = _{ ws? ~ "," ~ ws | space* ~ comment? ~ newline ~ ws? }

primary = _{
    scope | call_like |
    collection | lit |
    global_path | local_path | ident | discard
}

ascription = { "[" ~ ws? ~ ident ~ ws ~ form ~ ws? ~ "]" }
scope = { "[" ~ ws? ~ infix_form ~ ws? ~ "]" }

// --- Calls ---

call_like = _{
    and_expr | or_expr | not_expr |
    do_expr |
    if_expr | match_expr | log_expr |
    call |
    lambda
}

and_expr = { "(" ~ ws? ~ "and" ~ ws ~ block ~ ws? ~ ")" }
or_expr = { "(" ~ ws? ~ "or" ~ ws ~ block ~ ws? ~ ")" }
not_expr = { "(" ~ ws? ~ "not" ~ ws ~ infix_form ~ ws? ~ ")" }
do_expr = { "(" ~  ws? ~ "do" ~ ws ~ block? ~ ws? ~ ")"}
if_expr = {
    "(" ~ ws? ~ "if" ~ ws ~
    block ~ (ws ~ "else:" ~ ws ~ form)? ~ ws? ~
    ")"
}
match_expr = {
    "(" ~ ws? ~ "match" ~ ws ~ form ~ ws ~
    block ~ ws? ~
    ")"
}
log_expr = { "(" ~ ws? ~ "log" ~ ws ~ forms ~ ws? ~ ")" }

call = { "(" ~ ws? ~ !(macro_expr ~ ws) ~ forms ~ ws? ~ ")" }
// Prevent macros from falling back onto normal calls.
macro_expr = { "and" | "or" | "not" | "if" | "match" }

lambda = { "\\(" ~ ws? ~ block ~ ws? ~ ")" }

// --- Collections ---

collection = _{ tuple }

tuple = { "{" ~ ws? ~ forms ~ ws? ~ "}" }

// --- Literals ---

lit = _{ int_lit | sym_lit | str_lit }

int_lit = @{ ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* | ASCII_DIGIT }
//float_lit = {}
sym_lit = @{ "." ~ name ~ ("/" ~ name)* }
str_lit = { single_str_lit }
//char_lit = {}

single_str_lit = _{ "\"" ~ str_segment ~ "\"" }
str_segment = { (!"\"" ~ ANY)* }

// --- Names ---

// We have to be careful to not try to match a label when we shouldn't,
// otherwise parsing infix expressions gets stuck on labels.
global_path = { ("/" ~ name)+ }
local_path = { !label ~ name ~ ("/" ~ name)+ }
ident = @{ !label ~ name }
discard = @{ "_" ~ ident? }

label = @{ name ~ ("/" ~ name)* ~ ":" }

name = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "-")* }

// --- Operators ---

prefix = _{
    // Width 3.
    bit_not |
    // Width 2.
    arrow_r |
    // Width 1.
    pos | neg | pin | unquote
}

bit_not = { "~~~" }
pos = { "+" }
neg = { "-" }
pin = { "^" }
unquote = { "~" }

infix = _{
    // Width 3.
    bit_and | bit_or | bit_xor | bit_shl | bit_shr |
    // Width 2.
    assoc | arrow_r | arrow_l | eq | ne | le | ge | pow | concat |
    // Width 1.
    assign | pipe | amp | lt | gt | add | sub | mul | div | rem
}

bit_and = { "&&&" }
bit_or = { "|||" }
bit_xor = { "^^^" }
bit_shl = { "<<<" }
bit_shr = { ">>>" }
assoc = { "=>" }
arrow_l = { "<-" }
arrow_r = { "->" }
eq = { "==" }
ne = { "/=" }
le = { "<=" }
ge = { ">=" }
pow = { "**" }
concat = { "++" }
assign = { "=" }
pipe = { "|" }
amp = { "&" }
lt = { "<" }
gt = { ">" }
add = { "+" }
sub = { "-" }
mul = { "*" }
div = { "/" }
rem = { "%" }

postfix = _{
    // Width 1.
    res | opt
}

res = { "!" }
opt = { "?" }

// --- Whitespace ---

ws = _{ (space | newline | comment)+ }

space = _{ " " | "\t" }
newline = _{ "\n" | "\r\n" | "\r" }
comment = _{ ";" ~ (!newline ~ ANY)* }
